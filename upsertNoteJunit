package axa.partners.clp.dms.migration.service;

import axa.partners.clp.dms.migration.data.ApplicationConfiguration;
import axa.partners.clp.dms.migration.data.decisions.Note;
import axa.partners.clp.dms.migration.data.dms.*;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.*;
import org.mockito.quality.Strictness;

import javax.sql.DataSource;
import java.lang.reflect.Method;
import java.sql.*;
import java.time.*;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class SelmedDMSUpdateServiceTest {

    @Mock
    DataSource dataSource;
    @Mock
    DataSource riskDataSource;
    @Mock
    DataSource decisionsDataSource;
    @Mock
    Connection connection;
    @Mock
    Statement st;
    @Mock
    ResultSet rs;
    @Mock
    PreparedStatement statement;

    private SelmedDMSUpdateService service;
    private final LocalDateTime now = LocalDateTime.ofInstant(Instant.now(), ZoneOffset.UTC);

    @BeforeEach
    void setup() throws Exception {

        when(dataSource.getConnection()).thenReturn(connection);
        when(riskDataSource.getConnection()).thenReturn(connection);
        when(decisionsDataSource.getConnection()).thenReturn(connection);

        when(connection.createStatement()).thenReturn(st);
        when(st.executeQuery(anyString())).thenReturn(rs);
        when(rs.next()).thenReturn(false);

        when(connection.prepareStatement(anyString())).thenReturn(statement);
        when(statement.executeUpdate()).thenReturn(1);
        when(statement.executeQuery()).thenReturn(rs);

        service = new SelmedDMSUpdateService(
                dataSource,
                riskDataSource,
                new ApplicationConfiguration(dataSource),
                decisionsDataSource
        );
    }

    @Test
    public void testSelmedDMSRisksApplicationFileUpdatePackage() throws Exception {
        SelmedDMSRisksApplicationFileUpdatePackage pkg = new SelmedDMSRisksApplicationFileUpdatePackage();
        pkg.setId(10000L);
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setFileNumber("1297284F");
        pkg.setLocked(true);
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");

        Method m = SelmedDMSUpdateService.class
                .getDeclaredMethod("updateSelmedDMSUpdatePackages", Connection.class, Entity.class);
        m.setAccessible(true);
        Assertions.assertTrue((boolean) m.invoke(service, connection, pkg));
    }

    @Test
    public void testSelmedDMSCoveragesUpdatePackage() throws Exception {
        SelmedDMSCoveragesUpdatePackage pkg = new SelmedDMSCoveragesUpdatePackage();
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setFileNumber("1297284F");
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");
        pkg.setAerasCappingApplies(true);
        pkg.setCoverageId("T287248478TDD");
        pkg.setCoverSubmitted(true);
        pkg.setCurrencyCode("EUR");
        pkg.setInsuredAmount(10000L);
        pkg.setLoanId(2378572835L);
        pkg.setMacaoCoverId("testID");
        pkg.setName(1234);
        pkg.setQuota(1.2);

        Method m = SelmedDMSUpdateService.class
                .getDeclaredMethod("updateSelmedDMSUpdatePackages", Connection.class, Entity.class);
        m.setAccessible(true);
        Assertions.assertTrue((boolean) m.invoke(service, connection, pkg));
    }

    @Test
    public void testSelmedDMSOptionsUpdatePackage() throws Exception {
        SelmedDMSOptionsUpdatePackage pkg = new SelmedDMSOptionsUpdatePackage();
        pkg.setOptionId("9EA01BC1-EACC-4172-6FEE-08D7DC85AD52");
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setFileNumber("1297284F");
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");
        pkg.setAuthorId("NGOSJ");
        pkg.setDescription("OPTIONS");
        pkg.setLoanId(1234L);

        Method m = SelmedDMSUpdateService.class
                .getDeclaredMethod("updateSelmedDMSUpdatePackages", Connection.class, Entity.class);
        m.setAccessible(true);
        Assertions.assertTrue((boolean) m.invoke(service, connection, pkg));
    }

    @Test
    public void testSelmedDMSDecisionsApplicationFileUpdatePackage() throws Exception {
        SelmedDMSDecisionsApplicationFileUpdatePackage pkg = new SelmedDMSDecisionsApplicationFileUpdatePackage();
        pkg.setId(10000L);
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setFileNumber("1297284F");
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");
        pkg.setHasMedicalRiskSheet(true);

        Method m = SelmedDMSUpdateService.class
                .getDeclaredMethod("updateSelmedDMSUpdatePackages", Connection.class, Entity.class);
        m.setAccessible(true);
        Assertions.assertTrue((boolean) m.invoke(service, connection, pkg));
    }

    @Test
    public void testSelmedDMSRisksUpdatePackage() throws Exception {
        SelmedDMSRisksUpdatePackage pkg = new SelmedDMSRisksUpdatePackage();
        pkg.setId(10000L);
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setFileNumber("1297284F");
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");
        pkg.setRiskType(2);
        pkg.setRiskId("26736273");

        Method m = SelmedDMSUpdateService.class
                .getDeclaredMethod("updateSelmedDMSUpdatePackages", Connection.class, Entity.class);
        m.setAccessible(true);
        Assertions.assertTrue((boolean) m.invoke(service, connection, pkg));
    }

    @Test
    public void testSelmedDMSNotesUpdatePackage() throws Exception {
        SelmedDMSNotesUpdatePackage pkg = new SelmedDMSNotesUpdatePackage();
        pkg.setId(10000L);
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");
        pkg.setRiskId("26736273");
        pkg.setAuthorId("NGO");
        pkg.setDescription("NOTES");
        pkg.setNoteId("123");
        pkg.setNoteType(2);

        Method m = SelmedDMSUpdateService.class
                .getDeclaredMethod("updateSelmedDMSUpdatePackages", Connection.class, Entity.class);
        m.setAccessible(true);
        Assertions.assertTrue((boolean) m.invoke(service, connection, pkg));
    }

    @Test
    public void testUpsertNote_PreMigration_InsertsNote() throws Exception {
        // build Note objext
        Note note = new Note(0L, "FILE123", now, "pre-mig note");

        PreparedStatement riskStmt = mock(PreparedStatement.class);
        PreparedStatement refStmt = mock(PreparedStatement.class);
        when(riskDataSource.getConnection()).thenReturn(connection);
        when(connection.prepareStatement(contains("FROM Risks r WHERE r.FileNumber"))).thenReturn(riskStmt, refStmt);

        ResultSet rsRisk = mock(ResultSet.class);
        ResultSet rsRef = mock(ResultSet.class);
        when(riskStmt.executeQuery()).thenReturn(rsRisk);
        when(refStmt.executeQuery()).thenReturn(rsRef);

        when(rsRisk.next()).thenReturn(true);
        when(rsRisk.getString(1)).thenReturn("RID123");
        when(rsRisk.getTimestamp(2)).thenReturn(Timestamp.valueOf(LocalDateTime.of(2023, 1, 1, 0, 0)));

        when(rsRef.next()).thenReturn(true);
        when(rsRef.getTimestamp(1)).thenReturn(Timestamp.valueOf(LocalDateTime.of(2022, 1, 1, 0, 0)));

        PreparedStatement preStmt = mock(PreparedStatement.class);
        when(connection.prepareStatement(contains("FROM Notes n WHERE n.RiskId"))).thenReturn(preStmt);
        ResultSet rsNotes = mock(ResultSet.class);
        when(preStmt.executeQuery()).thenReturn(rsNotes);
        when(rsNotes.next()).thenReturn(false);

        PreparedStatement insertStmt = mock(PreparedStatement.class);
        when(connection.prepareStatement(startsWith("INSERT INTO Notes"))).thenReturn(insertStmt);
        when(insertStmt.executeUpdate()).thenReturn(1);

        service.upsertNote(note, now);

        // verify the INSERT
        verify(insertStmt).executeUpdate();
    }

    @Test
    public void testUpsertNote_PostMigration_InsertsNote() throws Exception {
        Note note = new Note(0L, "FILE123", now, "post-mig note");

        PreparedStatement riskStmt = mock(PreparedStatement.class);
        PreparedStatement refStmt = mock(PreparedStatement.class);
        when(riskDataSource.getConnection()).thenReturn(connection);
        when(connection.prepareStatement(contains("FROM Risks r WHERE r.FileNumber"))).thenReturn(riskStmt, refStmt);

        ResultSet rsRisk = mock(ResultSet.class);
        ResultSet rsRef = mock(ResultSet.class);
        when(riskStmt.executeQuery()).thenReturn(rsRisk);
        when(refStmt.executeQuery()).thenReturn(rsRef);

        when(rsRisk.next()).thenReturn(true);
        when(rsRisk.getString(1)).thenReturn("RID123");
        when(rsRisk.getTimestamp(2)).thenReturn(Timestamp.valueOf(LocalDateTime.of(2023, 1, 1, 0, 0)));

        when(rsRef.next()).thenReturn(true);
        when(rsRef.getTimestamp(1)).thenReturn(Timestamp.valueOf(LocalDateTime.of(2020, 1, 1, 0, 0)));

        PreparedStatement postStmt = mock(PreparedStatement.class);
        ResultSet rsNotes = mock(ResultSet.class);
        when(connection.prepareStatement(contains("FROM Notes n WHERE n.RiskId"))).thenReturn(postStmt);
        when(postStmt.executeQuery()).thenReturn(rsNotes);
        when(rsNotes.next()).thenReturn(false);

        // insert stub
        PreparedStatement insertStmt = mock(PreparedStatement.class);
        when(connection.prepareStatement(startsWith("INSERT INTO Notes"))).thenReturn(insertStmt);
        when(insertStmt.executeUpdate()).thenReturn(1);

        service.upsertNote(note, now);

        //Verify the Insert
        verify(insertStmt).executeUpdate();
    }

    @Test
    public void testInsertClosingDossierNote_PreMigration_WithExistingMacaoNote() throws Exception {
        LocalDateTime original = LocalDateTime.of(2025, 5, 12, 10, 0);
        Note note = new Note(123L, "FILE123", original, "pre-mig note");
        // stub risk info/ref date so isPreMigration(...) == true
        PreparedStatement riskStmt = mock(PreparedStatement.class);
        PreparedStatement refStmt = mock(PreparedStatement.class);
        ResultSet rsRisk = mock(ResultSet.class);
        ResultSet rsRef = mock(ResultSet.class);

        when(riskDataSource.getConnection()).thenReturn(connection);
        when(connection.prepareStatement(contains("FROM Risks r WHERE r.FileNumber"))).thenReturn(riskStmt, refStmt);
        when(riskStmt.executeQuery()).thenReturn(rsRisk);
        when(rsRisk.next()).thenReturn(true);
        when(rsRisk.getString(1)).thenReturn("RID123");

        when(rsRisk.getTimestamp(2)).thenReturn(Timestamp.valueOf("2023-01-01 00:00:00"));

        when(refStmt.executeQuery()).thenReturn(rsRef);
        when(rsRef.next()).thenReturn(true);
        when(rsRef.getTimestamp(1)).thenReturn(Timestamp.valueOf("2024-01-01 00:00:00"));

        PreparedStatement preStmt = mock(PreparedStatement.class);
        ResultSet rsNotes = mock(ResultSet.class);
        when(connection.prepareStatement(contains("FROM Notes n WHERE n.RiskId"))).thenReturn(preStmt);
        when(preStmt.executeQuery()).thenReturn(rsNotes);
        when(rsNotes.next()).thenReturn(true);

        PreparedStatement closeStmt = mock(PreparedStatement.class);
        when(connection.prepareStatement(startsWith("INSERT INTO Notes"))).thenReturn(closeStmt);

        SelmedDMSUpdateService service = new SelmedDMSUpdateService(
                dataSource, riskDataSource, new ApplicationConfiguration(dataSource), decisionsDataSource
        );

        service.upsertNote(note, original);

        ArgumentCaptor<Timestamp> tsCaptor = ArgumentCaptor.forClass(Timestamp.class);
        // verify setTimestamp(2, original+2minutes)
        verify(closeStmt).setTimestamp(eq(2), tsCaptor.capture());
        LocalDateTime expectedPlus2 = original.plusMinutes(2);
        Assertions.assertEquals(Timestamp.valueOf(expectedPlus2), tsCaptor.getValue());
        verify(closeStmt).setString(eq(4), eq("Dossier cloturé sans demande de conseil"));
        verify(closeStmt).executeUpdate();
    }

    @Test
    public void testInsertClosingDossierNote_PostMigration_NoExistingMacaoNote() throws Exception {
        LocalDateTime original = LocalDateTime.of(2025, 5, 12, 10, 0);
        Note note = new Note(0L, "FILE123", original, "post-mig note");
        // stub risk info/ref date so isPreMigration(...) == false
        PreparedStatement riskStmt = mock(PreparedStatement.class);
        PreparedStatement refStmt = mock(PreparedStatement.class);
        ResultSet rsRisk = mock(ResultSet.class);
        ResultSet rsRef = mock(ResultSet.class);

        when(riskDataSource.getConnection()).thenReturn(connection);
        when(connection.prepareStatement(contains("FROM Risks r WHERE r.FileNumber"))).thenReturn(riskStmt, refStmt);
        when(riskStmt.executeQuery()).thenReturn(rsRisk);
        when(rsRisk.next()).thenReturn(true);
        when(rsRisk.getString(1)).thenReturn("RID123");
        when(rsRisk.getTimestamp(2)).thenReturn(Timestamp.valueOf("2025-01-01 00:00:00"));

        when(refStmt.executeQuery()).thenReturn(rsRef);
        when(rsRef.next()).thenReturn(true);
        when(rsRef.getTimestamp(1)).thenReturn(Timestamp.valueOf("2024-01-01 00:00:00"));

        PreparedStatement postStmt = mock(PreparedStatement.class);
        ResultSet rsNotes = mock(ResultSet.class);
        when(connection.prepareStatement(contains("FROM Notes n WHERE n.RiskId"))).thenReturn(postStmt);
        when(postStmt.executeQuery()).thenReturn(rsNotes);
        when(rsNotes.next()).thenReturn(false);

        PreparedStatement closeStmt = mock(PreparedStatement.class);
        when(connection.prepareStatement(startsWith("INSERT INTO Notes"))).thenReturn(closeStmt);

        SelmedDMSUpdateService service = new SelmedDMSUpdateService(
                dataSource, riskDataSource, new ApplicationConfiguration(dataSource), decisionsDataSource
        );

        service.upsertNote(note, original);

        ArgumentCaptor<Timestamp> tsCaptor = ArgumentCaptor.forClass(Timestamp.class);
        verify(closeStmt).setTimestamp(eq(2), tsCaptor.capture());
        LocalDateTime expectedPlus2 = original.plusMinutes(2);
        Assertions.assertEquals(Timestamp.valueOf(expectedPlus2), tsCaptor.getValue());
        verify(closeStmt).setString(eq(4), eq("Dossier cloturé sans demande de conseil"));
        verify(closeStmt).executeUpdate();
    }
}
