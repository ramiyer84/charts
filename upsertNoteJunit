package axa.partners.clp.dms.migration.service;

import axa.partners.clp.dms.migration.data.ApplicationConfiguration;
import axa.partners.clp.dms.migration.data.decisions.Note;
import axa.partners.clp.dms.migration.data.dms.SelmedDMSCoveragesUpdatePackage;
import axa.partners.clp.dms.migration.data.dms.SelmedDMSDecisionsApplicationFileUpdatePackage;
import axa.partners.clp.dms.migration.data.dms.SelmedDMSNotesUpdatePackage;
import axa.partners.clp.dms.migration.data.dms.SelmedDMSOptionsUpdatePackage;
import axa.partners.clp.dms.migration.data.dms.SelmedDMSRisksApplicationFileUpdatePackage;
import axa.partners.clp.dms.migration.data.dms.SelmedDMSRisksUpdatePackage;
import axa.partners.clp.dms.migration.data.dms.Entity;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.quality.Strictness;
import org.mockito.junit.jupiter.MockitoSettings;

import javax.sql.DataSource;
import java.lang.reflect.Method;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class SelmedDMSUpdateServiceTest {

    @Mock DataSource dataSource;
    @Mock DataSource riskDataSource;
    @Mock DataSource decisionsDataSource;
    @Mock Connection connection;
    @Mock Statement st;
    @Mock ResultSet rs;
    @Mock PreparedStatement statement;

    private SelmedDMSUpdateService service;
    private LocalDateTime now;

    @BeforeEach
    public void setup() throws Exception {
        now = LocalDateTime.ofInstant(java.time.Instant.now(), ZoneOffset.UTC);

        // common mocks
        when(dataSource.getConnection()).thenReturn(connection);
        when(riskDataSource.getConnection()).thenReturn(connection);
        when(decisionsDataSource.getConnection()).thenReturn(connection);
        when(connection.createStatement()).thenReturn(st);
        when(connection.prepareStatement(anyString())).thenReturn(statement);
        when(statement.executeUpdate()).thenReturn(1);
        when(st.executeQuery(anyString())).thenReturn(rs);

        service = new SelmedDMSUpdateService(
            dataSource,
            riskDataSource,
            new ApplicationConfiguration(dataSource),
            decisionsDataSource
        );
    }

    // ─── the original 6 tests ──────────────────────────────────

    @Test
    public void testSelmedDMSRisksApplicationFileUpdatePackage() throws Exception {
        var pkg = new SelmedDMSRisksApplicationFileUpdatePackage();
        pkg.setId(10000L);
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setFileNumber("1297284F");
        pkg.setLocked(true);
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");

        assertTrue(invokeUpdate(pkg));
    }

    @Test
    public void testSelmedDMSCoveragesUpdatePackage() throws Exception {
        var pkg = new SelmedDMSCoveragesUpdatePackage();
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setFileNumber("1297284F");
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");
        pkg.setAerasCappingApplies(true);
        pkg.setCoverageId("T287248478TDD");
        pkg.setCoverSubmitted(true);
        pkg.setCurrencyCode("EUR");
        pkg.setInsuredAmount(10000L);
        pkg.setLoanId(2378572835L);
        pkg.setMacaoCoverId("testID");
        pkg.setName(1234);
        pkg.setQuota(1.2);

        assertTrue(invokeUpdate(pkg));
    }

    @Test
    public void testSelmedDMSOptionsUpdatePackage() throws Exception {
        var pkg = new SelmedDMSOptionsUpdatePackage();
        pkg.setOptionId("9EA01BC1");
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setFileNumber("1297284F");
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");
        pkg.setAuthorId("NGOSJ");
        pkg.setDescription("OPTIONS");
        pkg.setLoanId(1234L);

        assertTrue(invokeUpdate(pkg));
    }

    @Test
    public void testSelmedDMSDecisionsApplicationFileUpdatePackage() throws Exception {
        var pkg = new SelmedDMSDecisionsApplicationFileUpdatePackage();
        pkg.setId(10000L);
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setFileNumber("1297284F");
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");
        pkg.setHasMedicalRiskSheet(true);

        assertTrue(invokeUpdate(pkg));
    }

    @Test
    public void testSelmedDMSRisksUpdatePackage() throws Exception {
        var pkg = new SelmedDMSRisksUpdatePackage();
        pkg.setId(10000L);
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setFileNumber("1297284F");
        pkg.setModificationDate(now);
        pkg.setOperation("TEST_OPERATION");
        pkg.setRiskType(2);
        pkg.setRiskId("26736273");

        assertTrue(invokeUpdate(pkg));
    }

    @Test
    public void testSelmedDMSNotesUpdatePackage() throws Exception {
        var pkg = new SelmedDMSNotesUpdatePackage();
        pkg.setId(10000L);
        pkg.setCreatedAt(now);
        pkg.setCreationDate(now);
        pkg.setModificationDate(now);
        pkg.setOperation("MODIFY");
        pkg.setRiskId("26736273");
        pkg.setAuthorId("NGO");
        pkg.setDescription("NOTES");
        pkg.setNoteId("123");
        pkg.setNoteType(2);

        assertTrue(invokeUpdate(pkg));
    }

    // ─── the 2 new upsertNote tests ────────────────────────────

    @Test
    public void testUpsertNote_PostMigration_InsertsNote() throws Exception {
        // build a Note with dummy id:
        Note note = new Note(
            0L,
            "FILE123",
            now,
            "New post-migration note"
        );

        // mock risk vs reference date
        PreparedStatement riskStmt = mock(PreparedStatement.class);
        PreparedStatement refStmt  = mock(PreparedStatement.class);
        ResultSet rsRisk = mock(ResultSet.class);
        ResultSet rsRef  = mock(ResultSet.class);

        when(riskDataSource.getConnection()).thenReturn(connection);
        when(connection.prepareStatement(contains("FROM Risks r WHERE r.FileNumber = ?")))
            .thenReturn(riskStmt, refStmt);
        when(riskStmt.executeQuery()).thenReturn(rsRisk);
        when(refStmt.executeQuery()).thenReturn(rsRef);

        // risk created after ref → post-migration
        when(rsRisk.next()).thenReturn(true);
        when(rsRisk.getString(1)).thenReturn("RID");
        when(rsRisk.getTimestamp(2)).thenReturn(Timestamp.valueOf("2024-01-02 00:00:00"));
        when(rsRef.next()).thenReturn(true);
        when(rsRef.getTimestamp(1)).thenReturn(Timestamp.valueOf("2023-01-01 00:00:00"));

        // no existing notes
        PreparedStatement notesStmt = mock(PreparedStatement.class);
        ResultSet notesRs = mock(ResultSet.class);
        when(connection.prepareStatement(contains("FROM Notes n WHERE n.RiskId = ?")))
            .thenReturn(notesStmt);
        when(notesStmt.executeQuery()).thenReturn(notesRs);
        when(notesRs.next()).thenReturn(false);

        // intercept the INSERT
        PreparedStatement insertStmt = mock(PreparedStatement.class);
        when(connection.prepareStatement(startsWith("INSERT INTO Notes")))
            .thenReturn(insertStmt);

        service.upsertNote(note, now);
        verify(insertStmt, times(1)).executeUpdate();
    }

    @Test
    public void testUpsertNote_PreMigration_UpdatesExistingNote() throws Exception {
        Note note = new Note(
            0L,
            "FILE123",
            now,
            "Updated pre-migration note"
        );

        // mock risk vs reference date
        PreparedStatement riskStmt = mock(PreparedStatement.class);
        PreparedStatement refStmt  = mock(PreparedStatement.class);
        ResultSet rsRisk = mock(ResultSet.class);
        ResultSet rsRef  = mock(ResultSet.class);

        when(riskDataSource.getConnection()).thenReturn(connection);
        when(connection.prepareStatement(contains("FROM Risks r WHERE r.FileNumber = ?")))
            .thenReturn(riskStmt, refStmt);
        when(riskStmt.executeQuery()).thenReturn(rsRisk);
        when(refStmt.executeQuery()).thenReturn(rsRef);

        // risk before ref → pre-migration
        when(rsRisk.next()).thenReturn(true);
        when(rsRisk.getString(1)).thenReturn("RID");
        when(rsRisk.getTimestamp(2)).thenReturn(Timestamp.valueOf("2022-01-01 00:00:00"));
        when(rsRef.next()).thenReturn(true);
        when(rsRef.getTimestamp(1)).thenReturn(Timestamp.valueOf("2023-01-01 00:00:00"));

        // existing note by migration author
        PreparedStatement preStmt = mock(PreparedStatement.class);
        ResultSet rsPre = mock(ResultSet.class);
        when(connection.prepareStatement(contains("AND n.AuthorId = ?"))).thenReturn(preStmt);
        when(preStmt.executeQuery()).thenReturn(rsPre);

        when(rsPre.next()).thenReturn(true);
        when(rsPre.getString(1)).thenReturn("EXISTID");
        when(rsPre.getString(2)).thenReturn("Old text");
        when(rsPre.getTimestamp(3)).thenReturn(Timestamp.valueOf("2022-01-01 00:00:00"));
        when(rsPre.getString(4)).thenReturn("macao.migration@partners.axa");
        when(rsPre.getInt(5)).thenReturn(0);

        // intercept UPDATE and history INSERT
        PreparedStatement updateStmt  = mock(PreparedStatement.class);
        PreparedStatement historyStmt = mock(PreparedStatement.class);
        when(connection.prepareStatement(startsWith("UPDATE Notes"))).thenReturn(updateStmt);
        when(connection.prepareStatement(startsWith("INSERT INTO NoteHistories"))).thenReturn(historyStmt);

        service.upsertNote(note, now);
        verify(updateStmt,  times(1)).executeUpdate();
        verify(historyStmt, times(1)).executeUpdate();
    }

    // ─── helper to invoke the private updateSelmedDMSUpdatePackages ───

    private boolean invokeUpdate(Entity pkg) throws Exception {
        Method m = SelmedDMSUpdateService.class
            .getDeclaredMethod("updateSelmedDMSUpdatePackages", Connection.class, Entity.class);
        m.setAccessible(true);
        return (boolean) m.invoke(service, connection, pkg);
    }
}